# 一键做卡工具（自动生成角色卡+世界书） 项目文档 (精简版)

本文档记录了项目的关键迭代和技术决策。

---

## v52.11.4 - 项目更名与UI文本更新

- **【项目更名】** 根据功能扩展，项目正式更名为“一键做卡工具（自动生成角色卡+世界书）”。
- **【UI更新】** 更新了 `manifest.json`、`popup.html` 和 `settings.html` 中的插件名称和标题。同时，将主界面的核心功能按钮重命名为“创建世界书+角色卡”，以更准确地反映其功能。
- **【文档更新】** 同步更新项目文档，全局替换旧名称为新名称。

## v52.11.6 - 支付网络优化

- **【核心优化】** 解决了支付功能在中国大陆地区需要VPN才能访问的问题。
    - **问题**: 原支付服务器部署在Vercel，其域名在国内访问不稳定，导致用户无法正常获取支付口令。
    - **解决方案**: 引入Cloudflare Workers作为反向代理。所有支付相关的网络请求现在都会通过一个国内访问速度更快的Cloudflare节点 (`cool-rain-6db8.1830488003.workers.dev`) 进行转发，从而绕过了Vercel的访问性问题。
    - **效果**: 现在用户无需使用任何代理工具，即可顺畅使用充值功能。

## v52.11.5 - BUG修复

- **【BUG修复】** 修复了因UI重命名引入的BUG，该BUG导致手动生成模式下的“生成/补充内容”按钮点击后无响应。
    - **问题**: 在 `index.js` 的 `handleGenerateFoundation` 函数中，用于操作AI响应文本框的jQuery选择器使用了错误的ID (`#aiResponseTextArea`)，而正确的ID应为 `#aiResponseTextArea-stage1`。
    - **解决方案**: 将 `index.js` 中所有相关的选择器从 `#aiResponseTextArea` 修正为 `#aiResponseTextArea-stage1`，恢复了按钮的正常功能。

## v52.11.3 - 支付流程UI优化

- **【UI优化】** 修复了支付按钮文本显示BUG，并优化了等待提示信息。
    - **问题 1**: 在特定操作流程下，“我已付款”按钮的文本可能错误地停留在“正在提交...”状态，造成用户困惑。
    - **解决方案 1**: 在 `initiateRecharge` 函数中，强制重置按钮文本为“我已付款”，确保每次进入该步骤时UI状态正确。
    - **问题 2**: 用户点击“我已付款”后，提示信息不够清晰，未告知用户可以安全关闭页面。
    - **解决方案 2**: 修改了等待审核时的提示文本，明确告知用户“您可以随时关闭此页面，充值成功后次数会自动到账”，充分利用了已有的离线补偿机制，提升用户体验。

## v52.11.2 - 修复后台订单显示BUG

- **【BUG修复】** 修复了后台管理页面会显示`pending`（待处理）状态订单的BUG。
    - **问题**: 后台 `/api/pending-orders` 接口错误地将`pending`状态的订单也一并返回，导致用户刚生成支付口令、还未确认付款时，该订单就出现在了管理后台，违背了“隐藏订单”的设计初衷。
    - **解决方案**: 修改了 `world-book-payment-server/api/index.js` 文件中的过滤器，确保 `/api/pending-orders` 接口 **只返回** 状态为 `user_confirmed` 的订单。
    - **效果**: 现在只有当用户明确点击“我已付款”按钮后，订单才会出现在后台管理页面等待审核，流程完全正确。

## v52.11.1 - 支付流程文档优化

- **【核心澄清】支付流程最终版详解**
    - **背景**: 为了彻底澄清支付流程，避免因旧文档或沟通不畅导致的误解，特此在文档最顶端明确最终版支付逻辑。
    - **最终流程**:
        1.  **生成口令 (创建`待处理`订单)**: 用户选择充值套餐后，前端请求 `/api/create-order`。服务器在数据库中创建一个状态为 `pending` (待处理) 的订单，并返回一个唯一的6位数`orderId`作为支付口令。此订单为“隐藏”状态，仅代表用户发起了意向。
        2.  **用户支付与确认**: 用户使用任意方式支付后，点击【我已付款】按钮。
        3.  **激活订单 (变为`待审核`状态)**: 前端调用 `/api/user-confirm-payment` 接口。服务器验证`orderId`后，将订单状态从 `pending` 更新为 `user_confirmed` (用户已确认/待审核)。**此时，订单才从“隐藏”变为“真实”，等待管理员处理。**
        4.  **启动轮询**: **只有在用户确认付款，订单变为 `user_confirmed` 状态后**，前端才开始轮询 `/api/order-status` 接口，检查管理员是否已完成审核。
        5.  **管理员审核**: 管理员在后台看到 `user_confirmed` 状态的订单，确认收款后，手动将订单状态更新为 `completed` (已完成)。
        6.  **充值到账**: 前端轮询到 `completed` 状态，为用户增加对应次数，并停止轮询。
    - **结论**: 此流程完全符合“先创建隐藏订单，用户确认后再激活”的模式，无任何临时JWT等复杂机制，确保了流程的简洁、高效与健壮。

---

## v52.x - UI与用户体验优化

- **v52.11.0**: **【支付流程最终版】优化支付流程，引入用户确认步骤**。
    - **问题**: 旧的支付流程会在用户选择档位后立即启动轮询，即使用户未支付也会持续向服务器发送请求，造成资源浪费。
    - **最终解决方案**:
        1.  **创建订单，获取口令**: 用户选择充值档位后，前端立即向 `/api/create-order` 请求，在数据库中创建一条 `status: 'pending'` 的订单，并获取唯一的6位数`orderId`作为支付口令。
        2.  **延迟轮询**: 此时，前端**不**启动轮询，只向用户展示支付二维码和`orderId`口令。
        3.  **用户确认，启动轮询**: 新增一个 `/api/user-confirm-payment` 端点。只有当用户点击“我已付款”按钮后，前端才会调用此接口，将订单状态更新为 `user_confirmed`，并**在此之后才开始轮询** `/api/order-status` 等待管理员最终确认。
    - **效果**: 此方案完美平衡了用户体验和后台性能。用户可以立即获取口令进行支付，而服务器轮询只在用户明确表示已付款后才开始，有效避免了无效请求。后台管理页面也能清晰区分“用户未操作”和“用户已付款待审核”的订单。

- **v52.10.1**: **修复离线订单补偿机制的触发时机BUG**。
    - **问题**: `v52.10.0`引入的离线订单检查函数 `checkPendingOrders()` 被错误地放在了仅执行一次的 `init()` 函数中，导致用户关闭再打开插件窗口（不刷新整个网页）时，补偿机制不执行。
    - **解决方案**: 将 `checkPendingOrders()` 函数的调用，从 `init()` 移动到悬浮按钮的 `click` 事件处理器中。
    - **效果**: 确保了**每次**用户点击悬浮按钮打开插件时，都会立即检查并补偿可能存在的离线支付，使该功能真正变得可靠。

- **v52.10.0**: **实现支付系统健壮性升级：引入离线订单补偿机制**。
    - **问题**: 用户在支付页面关闭插件后，如果支付成功，由于前台轮询已停止，充值次数无法到账，导致用户资金损失。
    - **解决方案**:
        1.  **记录待支付订单**: 用户发起充值时，将生成的`orderId`存入浏览器的`localStorage`。
        2.  **启动时自动检查**: 每次插件初始化时，自动读取`localStorage`中的待支付订单列表。
        3.  **后台静默补偿**: 插件会静默地向服务器查询这些订单的最新状态。如果发现有订单已完成，则自动为用户增加对应次数，并从待处理列表中移除该订单。
        4.  **友好提示**: 如果发生了补偿，会通过`toastr`明确告知用户“欢迎回来！检测到您有已支付的订单，已成功为您补充 XX 次调用次数。”，确保用户知情。
    - **意义**: 此机制彻底解决了因用户关闭页面而导致的充值丢失问题，确保了支付系统的健壮性和可靠性。

- **v52.9.0**: **修复移动端UI BUG并重构充值流程**。
    - **问题 1**: 悬浮按钮在移动端因 `touchstart` 事件中的 `e.preventDefault()` 调用，导致 `click` 事件被阻止，无法打开插件主窗口。
    - **解决方案 1**: 将 `e.preventDefault()` 从 `dragStart` 函数移动到 `dragMove` 函数内部，确保只在用户真正拖动时才阻止页面滚动，从而修复了单击操作。
    - **问题 2**: 充值弹窗在移动端存在显示问题，且用户体验与插件其他部分不一致。
    - **解决方案 2**: 将充值功能从一个覆盖式弹窗（modal）彻底重构为一个独立的全屏页面。这不仅解决了移动端的显示BUG，还统一了插件的导航流程，使其更加健壮和用户友好。

- **v52.8.0**: **修复全自动生成功能BUG**。
    - **问题**: 全自动生成流程在第一步“任务拆解”时，因AI返回数据不完整导致`Unexpected end of JSON input`错误。
    - **根源分析**:
        1.  **API调用路径硬编码**: `callApiWithCredits`函数被错误地修改为强制使用自定义API路径，导致在使用酒馆内置API时调用失败。
        2.  **关键参数丢失**: 在任务拆解的API请求中，移除了`max_tokens`参数，这与v37.0.0版本修复过的问题一致，是导致AI返回不完整JSON的直接原因。
    - **解决方案**:
        1.  将`callApiWithCredits`函数恢复为根据用户设置（酒馆或自定义）动态选择API路径的正确逻辑。
        2.  在任务拆解的API请求负载中，重新添加`max_tokens: 60000`参数，确保AI有足够容量生成完整的指令JSON。
- **v52.7.0**: **重构充值弹窗显示逻辑**。放弃了直接用JS修改内联样式的方式，改为通过添加/移除`.wbg-is-visible` CSS类来控制显示和隐藏，使代码更健壮、更易于维护。
- **v52.6.0**: **修复充值弹窗移动端显示BUG**。通过调整CSS，使其在小屏幕上采用顶部对齐（`flex-start`）而非居中对齐，解决了弹窗被遮挡的问题。
- **v52.5.0**: **彻底修复悬浮按钮（FAB）定位问题**。
    - **问题**: CSS的`transform`居中样式与JS的拖动定位逻辑冲突，且位置记忆功能被禁用。
    - **最终解决方案**: 移除了冲突的CSS居中样式，恢复其经典的右下角定位。同时，重新启用了`localStorage`位置记忆，并增加了`keepInBounds`边界检测，确保按钮在任何情况下都保持在屏幕可视范围内。
- **v52.2.0**: **修复主弹窗移动端UI BUG**。修正了移动端媒体查询中的CSS，确保主弹窗在所有设备上都能正确垂直居中。

---

## v38.0.0 - v51.0.0: 支付系统集成与史诗级调试

此阶段完成了从零到一的半自动支付系统，并解决了一系列复杂的生产环境问题。

- **v38.0.0**: **核心功能：集成二维码充值系统**。
    - **方案**: 鉴于个人开发者限制，设计并实现了一套“二维码+支付口令”的半自动支付方案。
    - **架构**: 采用前后端分离，前端（插件）负责展示UI和轮询，后端（Vercel无服务器函数）负责创建订单和更新状态。收款由开发者在支付宝后台查看备注后，通过一个简单的内部管理页面手动确认。

- **核心问题修复总结**:
    - **1. Vercel部署与路由 (v38.3.0, v41.0.0, v42.0.0)**:
        - **问题**: API出现CORS错误，后台管理页面`admin.html`出现404。
        - **最终方案**: 采用“单一入口架构”。`vercel.json`配置为将所有请求`/(.*)`无条件转发给`api/index.js`。由Express应用自身通过`express.static(path.join(__dirname, '../public'))`提供静态文件服务，并处理所有API路由，实现了逻辑的统一和稳定。
    - **2. 后端稳定性与数据存储 (v39.0.0, v43.0.0, v46.0.0, v48.0.0, v50.0.0)**:
        - **问题**: 服务器频繁因文件读写失败、数据解析错误、未捕获的异常而崩溃，返回“500 Internal Server Error”。
        - **最终方案**:
            - **数据库迁移 (v39.0.0)**: 将数据存储从不稳定的`db.json`文件，彻底迁移至高可用的**Vercel KV (基于Redis) 云数据库**，从根本上解决了服务器崩溃问题。
            - **健壮性重构**: 为所有API增加了`try...catch`块，将中间件逻辑内联，并增加了全局错误处理中间件，确保任何错误都能被优雅捕获并返回标准JSON。
    - **3. CORS策略 (v38.1.0, v45.0.0, v51.0.0)**:
        - **问题**: 浏览器因CORS策略阻止跨域请求。
        - **最终方案**: 移除了`vercel.json`中所有CORS相关的`headers`，在Express后端使用`cors`库，并配置了精确的来源白名单，完美解决了跨域问题。
    - **4. 调试工具 (v44.0.0, v47.0.0)**:
        - **方案**: 为前端的`fetch`请求增加了详细的日志功能，在捕获到错误时，首先打印服务器返回的**原始文本** (`response.text()`)。这对于识破服务器返回的是HTML错误页面而非预期的JSON至关重要。

---

## v20.0.0 - v37.0.0: 核心功能增强与健壮性提升

- **v37.0.0**: **修复AI回复截断问题**。将API调用中的参数从错误的`max_new_tokens`修正为正确的`max_tokens`，确保能接收到完整的JSON数据。
- **v36.0.0**: **引入“不死鸟”重试机制**。将自动重试增加到10次，并在失败后提供“手动重试”按钮，允许用户无限次地对失败步骤进行重试。
- **v35.0.0**: **增加全流程AI原始数据日志**。为所有AI调用环节增加了“上帝视角”调试功能，无论成功失败，都在UI上显示原始返回数据。
- **v30.0.0**: **最终修复UI自动刷新**。根据官方教程，通过直接调用SillyTavern的全局函数`window.getCharacters()`和`window.select_rm_info()`，实现了创建角色后稳定、可靠的UI刷新和高亮。
- **v22.1.1**: **修复角色卡创建API字段名**。将提交给后端的`first_message`字段修正为正确的`first_mes`，解决了“第一条消息”丢失的BUG。
- **v21.0.0**: **强制角色卡与世界书命名一致**。通过代码强制将生成的“导演”角色卡名称与世界书名称同步，并优化了相关提示词。
- **v20.0.0**: **功能闭环：集成角色卡自动生成与绑定**。新增了核心功能，在世界书创建完成后，能自动（或手动）为其生成一个配套的“导演”角色卡，并将两者绑定，形成完整的创作流程。

---

## v1.0.0 - v19.0.0: 奠基与核心功能迭代

此阶段完成了插件从0到1的构建，并逐步完善了核心功能。

- **健壮性与重试机制 (v15-v18)**: 引入并完善了自动化任务的容错与重试架构。
- **自动化流程增强 (v11-v14)**: 新增并完善了“全自动生成”模式，支持自定义API和后台运行。
- **代码重构与更新 (v8-v10)**: 对项目进行底层重构，实现了数据与逻辑分离，并建立了自动更新机制。
- **核心功能与提示词工程 (v1-v7)**: 实现了四阶段创作的核心功能，并根据用户反馈对提示词进行了多次革命性重构，奠定了高质量内容生成的基础。
- **项目启动 (v0.x)**: 搭建了项目基本框架，建立了“生成-审核-上传”的核心工作流。
